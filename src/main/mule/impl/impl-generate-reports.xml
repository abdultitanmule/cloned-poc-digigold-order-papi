<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:validation="http://www.mulesoft.org/schema/mule/validation" xmlns:sftp="http://www.mulesoft.org/schema/mule/sftp"
	xmlns:json-logger="http://www.mulesoft.org/schema/mule/json-logger"
	xmlns:os="http://www.mulesoft.org/schema/mule/os" xmlns:file="http://www.mulesoft.org/schema/mule/file" xmlns:vm="http://www.mulesoft.org/schema/mule/vm" xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
http://www.mulesoft.org/schema/mule/vm http://www.mulesoft.org/schema/mule/vm/current/mule-vm.xsd
http://www.mulesoft.org/schema/mule/file http://www.mulesoft.org/schema/mule/file/current/mule-file.xsd
http://www.mulesoft.org/schema/mule/os http://www.mulesoft.org/schema/mule/os/current/mule-os.xsd
http://www.mulesoft.org/schema/mule/json-logger http://www.mulesoft.org/schema/mule/json-logger/current/mule-json-logger.xsd
http://www.mulesoft.org/schema/mule/sftp http://www.mulesoft.org/schema/mule/sftp/current/mule-sftp.xsd
http://www.mulesoft.org/schema/mule/validation http://www.mulesoft.org/schema/mule/validation/current/mule-validation.xsd">
	<flow name="impl-generate-reports" doc:id="335ee61b-3fe4-4a4d-ab29-8abfc6526e4b">
		<json-logger:logger doc:name="Logger" doc:id="0406acea-d009-4e43-8fd8-ce5d1c7eb63b" config-ref="JSON_Logger_Config" message='#["Starting the report generation for " ++ payload.reportType]' category="${log.category}" />
		<vm:publish queueName="reportsExtractQueue" doc:name="reportsExtractQueue" doc:id="8c18a4f5-f51a-4043-8e7b-74813bff0d63" config-ref="transactions_vm_Config" sendCorrelationId="ALWAYS" />
		<error-handler ref="reports-global-error-handler" />
	</flow>
	
	<flow name="extract-reports-generation-data-flow" doc:id="bc21ea4c-a4fc-4dac-8d3e-61de53bd4af9" >
		<vm:listener doc:name="reportsExtractQueue" doc:id="de38ede6-0240-4b80-9d05-c369c0e85aae" config-ref="transactions_vm_Config" queueName="reportsExtractQueue" timeoutUnit="MINUTES"/>
		<json-logger:logger doc:name="Logger" doc:id="2b59c2cc-5515-4510-8d02-6d674dac9cb0" config-ref="JSON_Logger_Config" message='#["Starting the report generation for " ++ payload.reportType]' tracePoint="FLOW" category="${log.category}">
			<json-logger:content ><![CDATA[#[import modules::JSONLoggerModule output application/json ---
{
    //payload: JSONLoggerModule::stringifyNonJSON(payload) 
    payload:  
    	{
			reportType: payload.reportType,
			variables: payload.variables,
	        dynamodbFetchCount: payload.dynamodbFetchCount,
			batchCount: payload.batchCount,
			count: payload.count,
	        lastEvaluatedKey: payload.lastEvaluatedKey
	      }
}]]]></json-logger:content>
		</json-logger:logger>
		<set-variable value="#[payload.reportType]" doc:name="reportType" doc:id="11d1c89c-7876-4832-879b-a84047036400" variableName="reportType"/>
		<set-variable value="#[%dw 2.0&#10;output application/json&#10;---&#10;payload default {}]" doc:name="previousPayload" doc:id="2d8e23ed-d503-45ed-b99c-c5ddff1ca33e" variableName="previousPayload"/>
		<set-variable value='#[import * from dw::core::Strings&#10;output application/java&#10;---&#10;camelize(vars.reportType replace " " with "") ++ "lastEvaluatedKey"]' doc:name="setObjectStoreNameForReports" doc:id="19905413-61cd-470d-a317-58a34d5d5ec9" variableName="setObjectStoreNameForReports" />
		<flow-ref doc:name="process-dynamo-order-sapi-transactions" doc:id="999bc535-7450-498f-ad10-04052af35ab3" name="process-dynamo-order-sapi-transactions"/>
		<set-payload value='#[%dw 2.0&#10;output application/json&#10;---&#10;&#10;{	&#10;	reportType : payload.reportType,&#10;	variables: vars.previouspayload.variables default {},&#10;	dynamodbFetchCount: (vars.previouspayload.dynamodbFetchCount default 0 ) + 1,&#10;	batchCount: (vars.previouspayload.batchCount),&#10;    count: (vars.previouspayload.count default 0 ) + (payload.count default 0),&#10;    ("lastEvaluatedKey": payload.lastEvaluatedKey) if (payload.lastEvaluatedKey?),   &#10;    "items":  (vars.previouspayload.items default []) ++ payload.items default []&#10;}]' doc:name="Agrregated Payload" doc:id="a304ef08-45bf-4115-8f1f-bbccc62e1786" />
		<json-logger:logger doc:name="Logger" doc:id="b684811f-8db0-4ae9-91ad-d423ba839513" config-ref="JSON_Logger_Config" message="After DynamoDbSAPI. Processing further" tracePoint="FLOW" category="${log.category}">
			<json-logger:content ><![CDATA[#[import modules::JSONLoggerModule output application/json ---
{
    //payload: JSONLoggerModule::stringifyNonJSON(payload) 
    payload:  
    	{
			reportType: payload.reportType,
			variables: payload.variables,
	        dynamodbFetchCount: payload.dynamodbFetchCount,
			batchCount: payload.batchCount,
			count: payload.count,
	        lastEvaluatedKey: payload.lastEvaluatedKey
	      }
}]]]></json-logger:content>
		</json-logger:logger>
		<choice doc:name="Choice" doc:id="7908ecb7-d6c3-4714-ae8b-846df5511846">
			<when expression="#[((payload.count &lt; p('reports.batchCount') and payload.lastEvaluatedKey != null))]">
				<vm:publish doc:name="reportsExtractQueue" doc:id="1ee0a503-83fa-4cbf-9c65-40777af9deec" config-ref="transactions_vm_Config" queueName="reportsExtractQueue" sendCorrelationId="ALWAYS"/>
			</when>
			<when expression="#[((payload.count &gt;= p('reports.batchCount') and payload.lastEvaluatedKey != null))]">
				<set-variable value="#[%dw 2.0&#10;output application/json&#10;---&#10;{&#10;	reportType: payload.reportType,&#10;	variables: payload.variables,&#10;	dynamodbFetchCount: payload.dynamodbFetchCount,&#10;    	batchCount: (payload.batchCount default 0) + 1,&#10;	count: 0,&#10;    lastEvaluatedKey: payload.lastEvaluatedKey default {}&#10;}]" doc:name="HeadersAndlastEvaluatedKey" doc:id="87378b91-6368-4d5f-ba2b-023b908da70b" variableName="HeadersAndlastEvaluatedKey" />
				<flow-ref name="process-sfcc-write-csv" doc:name="process-sfcc-write-csv" doc:id="68ef7345-0759-4667-a785-aa4276882f7e"></flow-ref>
				<set-payload value='#[vars.HeadersAndlastEvaluatedKey]' doc:name="Set Payload" doc:id="928e4b5f-cf99-4f26-b4a0-f30893e27860" />
				<os:store doc:name="vars.setObjectStoreNameForReports" doc:id="22d4d03b-7c22-4f88-9e8b-e410d9640a98" key="#[vars.setObjectStoreNameForReports]" >
					<os:value ><![CDATA[#[vars.HeadersAndlastEvaluatedKey.lastEvaluatedKey]]]></os:value>
				</os:store>
				<vm:publish doc:name="reportsExtractQueue" doc:id="cf9fad30-9491-4f64-9bfa-f6cb22930279" config-ref="transactions_vm_Config" queueName="reportsExtractQueue" sendCorrelationId="ALWAYS"/>
			</when>
			<otherwise >
				<choice doc:name="Choice" doc:id="7ad01111-a421-409a-a7b7-698c4103ad79" >
					<when expression="#[payload.batchCount==1 and payload.count == 0]">
						<json-logger:logger doc:name="Logger" doc:id="86c58dd8-d5dc-4363-a32b-11fe7db1e1ed" config-ref="JSON_Logger_Config" message='#["No Report to be generated for the " ++ payload.reportType]' tracePoint="FLOW" category="${log.category}">
							<json-logger:content ><![CDATA[#[import modules::JSONLoggerModule output application/json ---
{
    //payload: JSONLoggerModule::stringifyNonJSON(payload) 
    payload:  
    	{
			reportType: payload.reportType,
			variables: payload.variables,
	        dynamodbFetchCount: payload.dynamodbFetchCount,
			batchCount: payload.batchCount,
			count: payload.count,
	        lastEvaluatedKey: payload.lastEvaluatedKey
	      }
}]]]></json-logger:content>
						</json-logger:logger>
					</when>
					<when expression="#[payload.count &gt; 0]">
						<flow-ref doc:name="process-sfcc-write-csv" doc:id="946532f8-a1df-471d-93a5-0e08f76743c9" name="process-sfcc-write-csv" />
					</when>
					<otherwise >
						<json-logger:logger doc:name="Logger" doc:id="6a4f1cb9-2e90-493e-a607-81f93579071e" config-ref="JSON_Logger_Config" message="Processing Complete. No more records to process" tracePoint="END" category="${log.category}">
							<json-logger:content ><![CDATA[#[import modules::JSONLoggerModule output application/json ---
{
    //payload: JSONLoggerModule::stringifyNonJSON(payload) 
    payload:  
    	{
			reportType: payload.reportType,
			variables: payload.variables,
	        dynamodbFetchCount: payload.dynamodbFetchCount,
			batchCount: payload.batchCount,
			count: payload.count,
	        lastEvaluatedKey: payload.lastEvaluatedKey
	      }
}]]]></json-logger:content>
						</json-logger:logger>
					</otherwise>
				</choice>
			</otherwise>
		</choice>
		<error-handler ref="reports-global-error-handler" />
	</flow>

	<flow name="process-sfcc-write-csv" doc:id="6868a542-3e6c-4d73-be89-479a061ec0ca" >
		<json-logger:logger doc:name="Logger" doc:id="eaf8ecc4-2053-4f0d-8942-ee951ba68946" config-ref="JSON_Logger_Config" message="Retrieving the sfcc information for the batch" tracePoint="BEFORE_TRANSFORM" category="${log.category}">
			<json-logger:content ><![CDATA[#[import modules::JSONLoggerModule output application/json ---
{
    //payload: JSONLoggerModule::stringifyNonJSON(payload) 
    payload:  
    	{
			reportType: payload.reportType,
			variables: payload.variables,
	        dynamodbFetchCount: payload.dynamodbFetchCount,
			batchCount: payload.batchCount,
			count: payload.count,
	        lastEvaluatedKey: payload.lastEvaluatedKey
	      }
}]]]></json-logger:content>
		</json-logger:logger>
		<flow-ref doc:name="process-sfcc-order-sapi-customer-info" doc:id="1800eae8-ce12-4afa-9705-f1b542b16596" name="process-sfcc-order-sapi-customer-info"/>
<!-- [STUDIO:"customerSearchResponse"]		<set-variable value="#[{}]" doc:name="customerSearchResponse" doc:id="ca74d12f-ccee-469a-a4c0-91a05f8a7433" variableName="customerSearchResponse"/> [STUDIO] -->
		<json-logger:logger doc:name="Logger" doc:id="9e696ccc-09df-4d86-a9cd-d878f1b4bf7e" config-ref="JSON_Logger_Config" message='Combining Transaction and SFCC Customer Info' tracePoint="BEFORE_TRANSFORM" category="${log.category}">
			<json-logger:content><![CDATA[#[import modules::JSONLoggerModule output application/json ---
{
    //payload: JSONLoggerModule::stringifyNonJSON(payload) 
    payload:  
    	{
			reportType: payload.reportType,
			variables: payload.variables,
	        dynamodbFetchCount: payload.dynamodbFetchCount,
			batchCount: payload.batchCount,
			count: payload.count,
	        lastEvaluatedKey: payload.lastEvaluatedKey
	      }
}]]]></json-logger:content>
		</json-logger:logger>
		<ee:transform doc:name="CombineTransaction and SFCC Data" doc:id="149fd3b0-a0bb-4815-b5f6-ef6b1174f211" >
			<ee:message >
				<ee:set-payload ><![CDATA[%dw 2.0

var customerGrouped=vars.customerSearchResponse groupBy $.CUSTOMER_NO
fun lookupCustomer(MEMBER_ID) =
    customerGrouped[MEMBER_ID][0]
output application/csv
---
payload.items map ((item) -> 
    {
    "SAFEGOLD_USERID": (customerGrouped[item.MEMBER_ID])[0].SAFEGOLD_USERID,
    "EMAIL": 	(customerGrouped[item.MEMBER_ID])[0].EMAIL,
    "MOBILEPHONE": (customerGrouped[item.MEMBER_ID])[0].MOBILEPHONE,
    ("PAY_TRANSACTION_ID": item.DGORDER_ID ++ "_" ++ item.TRANSACTION_ID) if(payload.reportType == p('reports.dropOrderReport.reportType')),
    ("REGISTRATION_DATE": (customerGrouped[item.MEMBER_ID])[0].REGISTRATION_DATE) if(payload.reportType != p('reports.dropOrderReport.reportType')),   
    ("SAFEGOLDTRANSACTION_ID": item.TRANSACTION_ID) if(payload.reportType != p('reports.dropOrderReport.reportType')),
    "TRANSACTION_DATE": item.TRANSACTION_DATE,
    "RATE_ID": item.RATE_ID,
    "GOLD_RATE": item.GOLD_RATE ,
    "GRAMS_PURCHASED": item.GRAMS_PURCHASED,
    "TOTALAMOUNT_INR": item.TOTAL_GOLD_AMOUNT,
    "TRANSACTION_TYPE": item.TRANSACTION_TYPE,
    "CHANNEL": item.CHANNEL,
    "PAYMENT_GATEWAY": item.PAYMENT_GATEWAY,
    "PAYMENT_METHOD": item.PAYMENT_METHOD,
    "TRANSACTION_STATUS": item.TRANSACTION_STATUS,
    ("SAFEGOLDTRANSACTION_ID": item.TRANSACTION_ID) if(payload.reportType == p('reports.dropOrderReport.reportType'))
    }
)


//payload.items map ((item) -> 
//	((customerGrouped[item.MEMBER_ID])[0] default {}) - 'CUSTOMER_NO' 
//	++ item
//)]]></ee:set-payload>
			</ee:message>
			<ee:variables >
				<ee:set-variable variableName="outputFileName" ><![CDATA[%dw 2.0
import p from Mule
var reportDateformat = now() as String {format: "ddMMyyyyHms"}

fun reportFolder(reportName) = 
	if(payload.reportType == p('reports.dropOrderReport.reportType')) 
		p('titan.sftp.dropOrderReport') 
	else 
	if (payload.reportType == p('reports.transactionReport.reportType')) 
		p('titan.sftp.transactionReport') 
	else
	if (payload.reportType == p('reports.transactionConsolidatedReport.reportType')) 
		p('titan.sftp.transactionConsolidatedReport') 
	else
	 	" "
output application/java
---
//reportFolder(vars.reportName) ++ (vars.reportType replace " " with "") ++ reportDateformat ++ ".csv"

reportFolder(vars.reportType) ++ (vars.reportType replace " " with "") ++ reportDateformat ++ ".csv"



/*fun reportFolder(reportType) = 
	  match {
	 	case p('dropOrderReportScheduler.reportType')    -> p('dropOrderReportScheduler.sftpOutputFileDirectory') 
		case p('transactionsReportScheduler.reportType') -> p('transactionsReportScheduler.sftpOutputFileDirectory')
		case p('transactionsConsolidatedReportScheduler.reportType') -> p('transactionsConsolidatedReportScheduler.sftpOutputFileDirectory')
	}*/

/*
fun reportFolder(reportType) = 
	if(reportType == p('dropOrderReportScheduler.reportType')) 
		p('dropOrderReportScheduler.sftpOutputFileDirectory') 
	else 
		if reportType == p('transactionsReportScheduler.reportType')) 
			p('transactionsReportScheduler.sftpOutputFileDirectory') 
		else
		if reportType == p('transactionsConsolidatedReportScheduler.reportType')) 
			p('transactionsConsolidatedReportScheduler.sftpOutputFileDirectory') 		
	
	
	 */
//	folderpath =  p('dropOrderReportScheduler.sftpOutputFileDirectory') ++ reportType ++ reportDateformat ++ ".csv"
//p('reportGenerationPath.sftpOutputFileDirectory') ++ (vars.batchTransactionData.headers.ReportType replace " " with "")  ++ "_" ++ now() as String {format: "ddMMyyyyHms"} ++ ".csv"]]></ee:set-variable>
			</ee:variables>
		</ee:transform>
		<sftp:write doc:name="WritetoSFTPfolder" doc:id="616965d0-6fcf-48aa-add2-24ba0d2cf344" config-ref="SFTP_Config" path="#[vars.outputFileName]" mode="APPEND"/>
		<choice doc:name="Choice" doc:id="5d7558b1-1897-4e32-bb02-7815f3e7bf48" >
			<when expression="#[vars.HeadersAndlastEvaluatedKey.lastEvaluatedKey == null]">
				<set-payload value='#[%dw 2.0&#10;output application/json&#10;---&#10;{&#10; "reportType": vars.reportType&#10;}]' doc:name="Set reportType to send to generate xls" doc:id="7a7f1281-4d33-428a-a358-63600dae0910" />
				<try doc:name="Try" doc:id="7dc0dd0e-8a10-4479-888d-dcb8376ce29f" >
					<os:remove doc:name="vars.setObjectStoreNameForReports" doc:id="6376bd8b-4f2b-4d93-9ada-530ef027da6f" key="#[vars.setObjectStoreNameForReports]" />
					<error-handler >
						<on-error-continue enableNotifications="true" logException="true" doc:name="On Error Continue" doc:id="e975b501-74fc-4a90-951f-0f8f21a33f16" type="OS:KEY_NOT_FOUND">
							<json-logger:logger doc:name="Logger" doc:id="094ae8d6-455d-4934-a15a-eb03d9e76cfa" config-ref="JSON_Logger_Config" message='#["No Object key found for " ++ vars.setObjectStoreNameForReports ++ " for the " ++ payload.reportType default " "]' tracePoint="END" category="${log.category}" priority="WARN"/>
						</on-error-continue>
					</error-handler>
				</try>
				<vm:publish doc:name="xlsReportsGenerationQueue" doc:id="f1314861-d112-4774-a762-6b801890277f" config-ref="transactions_vm_Config" queueName="xlsReportsGenerationQueue" sendCorrelationId="ALWAYS" />
			</when>
			<otherwise >
				<json-logger:logger doc:name="Logger" doc:id="40b4260a-2a6c-450f-9eb8-c73d8c518104" config-ref="JSON_Logger_Config" message='#["Completed the End of the Customer and Transaction merge"]' tracePoint="END" category="${log.category}">
			<json-logger:content><![CDATA[#[import modules::JSONLoggerModule output application/json ---
{
    //payload: JSONLoggerModule::stringifyNonJSON(payload) 
    payload:  
    	{
			reportType: payload.reportType,
			variables: payload.variables,
	        dynamodbFetchCount: payload.dynamodbFetchCount,
			batchCount: payload.batchCount,
			count: payload.count,
	        lastEvaluatedKey: payload.lastEvaluatedKey
	      }
}]]]></json-logger:content>
		</json-logger:logger>
			</otherwise>
		</choice>
		<error-handler ref="reports-global-error-handler" />
	</flow>
</mule>
